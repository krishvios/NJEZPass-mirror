//
//  LoginInteractor.swift
//  NJEZPass
//
//  Created by Anshu Sharma on 22/07/19.
//  Copyright (c) 2019 Anshu Sharma. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol LoginBiometricLogic
{
  func checkForDeviceBiometricCapabilities(request: Login.Biometric.CheckBiometricModes.Request)
    func performBiometricAuth(request: Login.ApiAuthentication.Request)
    func performApiAuth(request: Login.ApiAuthentication.Request)
    func getStoredCredential(_ request: Login.KeyChain.Request)

}

protocol LoginDataStore
{
  //var name: String { get set }
}

class LoginInteractor: LoginBiometricLogic, LoginDataStore
{
  var presenter: LoginPresentationLogic?
  var biometricWorker = BiometricAuthSupervisor(worker: BiometricAuthWorker())
  //var name: String = ""
  
  // MARK: Do something
  
  func checkForDeviceBiometricCapabilities(request: Login.Biometric.CheckBiometricModes.Request )
  {
    
    let mode = biometricWorker.checkAvailableBiometricMode()
    var enrollStatus: Bool = false
    if let eStatus  = UserDefaults.standard.object(forKey: ConstantKeys.biometricLoginEnabled.rawValue){
        enrollStatus = eStatus as! Bool
    }
    let response = Login.Biometric.CheckBiometricModes.Response(avilableMode: mode, isEnrolled: enrollStatus)
    presenter?.presentBiometricBtn(response: response)
  }
    
    func performBiometricAuth(request: Login.ApiAuthentication.Request)
    {
        biometricWorker.performBiometricAuth{ (success:Bool, error: String) in
            let response = Login.ApiAuthentication.Response(success: success, errorMsg: error)
            if !success{
            self.presenter?.presentBiometricAuth(response: response)
            }else{
                if request.isFirstTimeUser{
                    self.performApiAuth(request: request)
                }else{
                    KeyChainHandler.fetchCredentialFromKeyChain(){req in
                        self.performApiAuth(request: req)
                    }
                }
            }
        }
        
    }
    
    func performApiAuth(request: Login.ApiAuthentication.Request)
    {
//        KeyChainHandler.saveCredentialInKeyChainIfNeeded(request)
        APIClient.login(email: request.username, password: request.password) { result  in
            switch result {
            case .success(let user):
                KeyChainHandler.saveCredentialInKeyChainIfNeeded(request)
                KeyChainHandler.saveSession(user)
                if request.loginMode == .biometric{
                    UserDefaults.standard.set(true, forKey: ConstantKeys.biometricLoginEnabled.rawValue)
                }
                let response = Login.ApiAuthentication.Response(success: true, errorMsg: "")
                self.presenter?.presentApiAuth(response: response)
            case .failure(let error):
                let response = Login.ApiAuthentication.Response(success: false, errorMsg: error.localizedDescription)
                self.presenter?.presentApiAuth(response: response)
            }
        }
        
    }
    
    func getStoredCredential(_ request: Login.KeyChain.Request)
    {
        KeyChainHandler.fetchCredentialFromKeyChain(){ req in
            let response = Login.KeyChain.Response(username: req.username, password: req.password)
            self.presenter?.presentSavedCredential(response)
        }
    }
    

}
